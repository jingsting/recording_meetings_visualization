<!DOCTYPE html>
<head>
    <meta charset = "utf-8">
    <style>
        /* sets the style of the title Meeting Analysis */
        h1 {
            font-size: 50px;
            color: navy;
            font-family: HelvNeueLightForIBM, Helvetica Neue, Arial, Helvetica, sans-serif;
            text-align: left;
        }
        body {
            background-color: white;
        }
    </style>
    <title>Visualization</title>
</head>
<body>
    <h1>Meeting Analysis</h1>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
        // var ourRequest = new XMLHttpRequest();
        // ourRequest.open('GET', *********FILE_LOCATION***************)
        // ourRequest.onload = function(){
        //     var RAWJSON_INFO=JSON.parse(ourRequest.responseText);
        // arbitrarily sets width, height, and diameter
        var width = 770;
        var height = 940;
        var diameter = 760;
        // controls the number of nodes
        // will read from Json file
        var numParticipants = 6;
        var participantSpeak = [];
        var participantTime = [];
        var participantColor = [];
        var k, i;
        for(k = 0; k < numParticipants; k++){
            participantSpeak[k] = 0;
            participantTime[k] = 0;
            participantColor[k] = 0;
        }
        // array of circles
        var circleData = [];
        var angle = 0;
        var x = 0;
        var x_1 = [];
        var y = 0;
        var y_1 = [];

        var tooltip = d3.select("body")
                        .append("div")
                        .style("position", "absolute")
                        .style("z-index", "10")
                        .style("visibility", "hidden")
                        .style("color", "white")
                        .style("padding", "8px")
                        .style("background-color", "rgba(0, 0, 0, 0.50)")
                        .style("border-radius", "6px")
                        .style("font", "12px sans-serif")
                        .text("tooltip");

        
        var alpha = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
        //http://bl.ocks.org/jfreyre/b1882159636cc9e1283a
        var colors = d3.scaleLinear().domain([1,50])
                            .interpolate(d3.interpolateHcl)
                            .range([d3.rgb("#FFFFFF"), d3.rgb('#191970')])
        // controls radius of circle the nodes are around
        var radius = 150;
        // creates container that the nodes are in with specific attributes
        var svgContainer = d3.select("body")
                            .append("svg")
                            .attr("width", 750)
                            .attr("height", 750)
                            .style("border", "1px solid black");
        // loops through for each participant and creates a node
        // and evenly spaces the nodes around the circle
        // in the future will use location data from Json to place people (Will need to generate relative coordinates in 2D unless the visualization is done in 3D)
        // also need to attach ID to each node
        for(i = 0; i < numParticipants; i++) 
        {
            // formula from here http://bl.ocks.org/bycoffe/3404776
            angle = (i / (numParticipants/2)) * Math.PI;
            x = (radius * Math.cos(angle)) + (width/2);
            y = (radius * Math.sin(angle)) + (width/2);
			x_1.push( ((radius+8) * Math.cos(angle)) + (width/2) );
            y_1.push( ((radius+8) * Math.sin(angle)) + (width/2) );
            var circle = svgContainer.append("circle")
                                .attr("cx", x)
                                .attr("cy", y)
                                .attr("r", 25)
                                .attr("id", i)
                                .style("stroke", "black")
                                .style("fill",colors(0))
                                .style("padding", 2)
                                .on("mouseover", function(d, id) {
                                    return tooltip.text("Times Spoken: " + parseInt(participantSpeak[id]) + " Total Time: "  + parseInt(participantTime[i]))
                                                .style("visibility", "visible");
                                })
                                .on("mousemove", function() {
                                    return tooltip.style("top", (d3.event.pageY-10)+"px")
                                                .style("left",(d3.event.pageX+10)+"px");
                                })
                                .on("mouseout", function() {
                                    return tooltip.style("visibility", "hidden");
                                })
            
            circleData.push(circle);

            var id = parseInt(circleData[i].attr("id"));

            var text = svgContainer.append("text")
                                .attr("x", x)
                                .attr("y", y + 6)
                                .text(alpha[id])
                                .attr("font-family", "san-serif")
                                .attr("font-size", "20px")
                                .attr("fill", "black")
                                .attr("text-anchor", "middle")
                                .on("mouseover", function(d, id) {
                                    return tooltip.text("Times Spoken: " + parseInt(participantSpeak[id]) + " Total Time: " + parseInt(participantTime[i]))
                                                .style("visibility", "visible");
                                })
                                .on("mousemove", function() {
                                    return tooltip.style("top", (d3.event.pageY-10)+"px")
                                                .style("left",(d3.event.pageX+10)+"px");
                                })
                                .on("mouseout", function() {
                                    return tooltip.style("visibility", "hidden");
                                })
               
            
        }

        var currentlySpeaking = true;
        var previouslySpoke = true;
        
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);
        currently(circleData,4);

        currently(circleData,3);
        currently(circleData,3);
        currently(circleData,3);
        currently(circleData,3);
        currently(circleData,3);
        
        previously(circleData, svgContainer, x_1,y_1,3);
        previously_remove(svgContainer);
        remPreviouslySpoke(circleData, 3);
        previously(circleData, svgContainer, x_1,y_1,4);
        previously_remove(svgContainer);
        remPreviouslySpoke(circleData, 4);
        previously(circleData, svgContainer, x_1,y_1,1);
        previously_remove(svgContainer);
        remPreviouslySpoke(circleData, 1);
        previously(circleData, svgContainer, x_1,y_1,3);
        previously_remove(svgContainer);
        remPreviouslySpoke(circleData, 3);
        previously(circleData, svgContainer, x_1,y_1,2);
        previously_remove(svgContainer);
        remPreviouslySpoke(circleData, 2);
        previously(circleData, svgContainer, x_1,y_1,0);
        previously_remove(svgContainer);
        remPreviouslySpoke(circleData, 0);
        previously(circleData, svgContainer, x_1,y_1,5);
        previously_remove(svgContainer);
        remPreviouslySpoke(circleData, 5);
        previously(circleData, svgContainer, x_1,y_1,3);
        previously_remove(svgContainer);
        remPreviouslySpoke(circleData, 3);
        previously(circleData, svgContainer, x_1,y_1,3);
        previously_remove(svgContainer);
        remPreviouslySpoke(circleData, 3);


        // function will be passed the id of the person currently speaking
        // and highlight them
        
        function currently(data,i) {
            if(currentlySpeaking) {		// this might come in handy so not removing
            
                data[i].style("stroke", "red")
                        .style("stroke-width", "10px");
            participantSpeak[i]++;
            participantColor[i]++;
            // var default_scale = d3.scaleQuantize().domain([0, 50]).range(['white','gray']);
            // syntax as seen on http://jonathansoma.com/tutorials/d3/color-scale-examples/
		    // A simple color scale created using quantization over 50 values, representing the scale going from blue to red
		    // TODO: Different nodes will have different color scales??
            data[i].style("fill",colors(participantColor[i]));
            
            }
        }
        
        // function will be passed the id of the person who
        // just spoke and highlight them
        // will also darken the color of the circle by 1 shade
        
        // Anyone who may have spoken previously will have their transcript 
        // displayed next to them in a text box
             
        function previously(data,svgC,x_r,y_r,i) // ,sti) 
        {

            timeSpoke(150,data,i,10);

            if(previouslySpoke) {		// this might come in handy so not removing
                data[i].style("stroke", "lightpink")
                        .style("stroke-width", "5px");
                // data[i].style("fill", colors[5]);
               
       //        var ls = sti.length;
       // TODO: After succesfully obtaining transcript data, get character count
       // and determine width of the rectangle on basis of that
       // Center text on rectangle
               
                 svgC.append("rect")
                .attr("x", parseInt(x_r[i]) + 30)
                .attr("y", parseInt(y_r[i]) + 30)
                .attr("rx",10)
                .attr("ry",10)
                .attr("id","rect_box")
                .attr("width", 100)
                .attr("height", 30)
                .attr("stroke","black")
                .attr("fill","none")
                .attr("id","rect_box")
                .attr("border", "1px solid black");
                
                
                svgC.append("text")
                .attr("x",parseInt(x_r[i]) + 35)
                .attr("y",parseInt(y_r[i]) + 50)
                .attr("id","text_box")
                .text("hello");
                
               
            }
        }
		// Remove the text box for use with other transcript elements 
       function previously_remove(svgC)
       {
            svgC.select("#rect_box").remove();
            svgC.select("#text_box").remove();    
       }
        // function will be passed the amount of time someone spoke in seconds
        // and change the size of the node proportionally to the amount
        // of time
        // function will also be passed id of person who spoke

        function remPreviouslySpoke(data, i) {
            data[i].style("stroke", "black");
            data[i].style("stroke-width", "1px");
        }
       
	function timeSpoke(timsec, data,i,ret) 
    {
            // currentRad = data[2].r;
            participantTime[i]+= timsec;
            var rad = parseInt(data[i].attr("r"));
            // increase one unit of radius every minute
            // every second then increases 1/60th of a unit, slow progression
            // assuming all individual conversation snippets do not exceed 15-20 seconds??
            data[i].attr("r", (rad + 1*(ret*timsec/60) ));
        }
        
        // ourRequest.send();
    </script>
    
</body>