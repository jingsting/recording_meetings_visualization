<!doctype html>
<html>
<title>L1 Visualization</title>
  
<head>
    <meta charset = "utf-8">
    <style>
        /* sets the style of the title Meeting Analysis */
        h1 {
            font-size: 50px;
            color: navy;
            font-family: HelvNeueLightForIBM, Helvetica Neue, Arial, Helvetica, sans-serif;
            text-align: left;
        }
        body {
            background-color: white;
        }
    </style>
    <title>Visualization</title>
</head>
<body>
  <h1>Meeting Analysis</h1>
  <h2>Meeting Timeline</h2>
    <p id="time_value"></p>
    <div id="time_line"></div>
  
    <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://unpkg.com/d3-simple-slider@0.2.1/build/d3-simple-slider.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/5.0.4/math.js"></script>
  <script src="https://d3plus.org/js/d3plus.js"></script>
  <script> src="" </script>

  <script src="math.js" type="text/javascript"></script>
    <script>
        // var ourRequest = new XMLHttpRequest();
        // ourRequest.open('GET', *********FILE_LOCATION***************)
        // ourRequest.onload = function(){
        //     var RAWJSON_INFO=JSON.parse(ourRequest.responseText);
        // arbitrarily sets width, height, and diameter
        
        
        ////////// TODO: Concrete method to read in data
        
        //////////////////////////////////////////////////////////////////////////
        // test_data
        // Assumption the data is sorted in time! That is, ID 0 happens before ID 1 and so on
        
        var test_data = [
        {speech:"this is a test",time:2,userID:0},
        {speech:"This is a test but this needs to be something long",time:5,userID:1},
        {speech:"The test string is a good thing to use for development",time:6,userID:2},
        {speech:"A complex sentence is a sentence that contains an independent clause and one or more dependent clauses. An independent clause can stand alone as a sentence, but a dependent clause even though it has a subject and a verb cannot stand alone.",time:40,userID:1},
        {speech:"JavaScript also defines two trivial data types, null and undefined, each of which defines only a single value. In addition to these primitive data types, JavaScript supports a composite data type known as object. We will cover objects in detail in a separate chapter. Note âˆ’ JavaScript does not make a distinction between integer values and floating-point values. All numbers in JavaScript are represented as floating-point values. JavaScript represents numbers using the 64-bit floating-point format defined by the IEEE 754 standard.",time:15,userID:1},
        {speech:"Now, imagine the challenge for Facebook. Facebook deals with enormous amount of text data on a daily basis in the form of status updates, comments etc. And it is all the more important for Facebook to utilise this text data to ",time:4,userID:3},
        {speech:"This library has gained a lot of traction in the NLP community and is a possible substitution to the gensim ",time:2,userID:4},
        {speech:"low magnitude. But FastText can produce vectors better than random by breaking the above word in chunks and using the vectors for those chunks to create a final vector for the word. In this particular",time:3,userID:5},
        {speech:"Words in their natural form cannot be used for any Machine Learning task in general. One way to use the words is to transform these words into some representations that capture some attributes of the word. It is analogous",time:3,userID:5}
        ];        
        //////////////////////////////////////////////////////////////////////////
        
        //////////////////////////////////////////////////////////////////////////
        /// TODO: (Not applicable to live data) After reading in data from various files, incorporate in all files into a single variable with all correlated speech and corresponding user ID's (including labeling which user says what and assigning a user id for every user and collecting it all into a variable as seen above), will depend on how we read the data, person by person? that is data comes in one person at a time? or multiple entries of people?
        
        // For now assuming implementing for one person at a time, that is, records of two people kept, the one who is speaking and the one who was previously speaking. The number of people is assumed to be known. The other data like the times someone spoke is accumulated though.
        
        // NOTE: Assuming no new users suddenly join in, focusing on getting a simple functionality working
        
        var width = 770;
        var height = 940;
        var diameter = 760;
        // controls the number of nodes
        // will read from Json file
        var participantSpeak = [];
        var participantTime = [];
        var timeSpoken = test_data.map(tra => tra.time);
        var userID_test = test_data.map(tra => tra.userID);
        var numParticipants = Math.max(...userID_test) + 1;
        var contsignal = true;
        var scale_arr = [];
        var scale_factor = 0.89;
        var activate_overlap_detection = false;
      
        var currentSpeaker = [];
        var previousSpeaker = [];
        
        // Although we can determine the number of times someone spoke from the test data we have, we are assuming that we will be using live data in the end, hence also assuming that we don't have that information at this point
        
        // var common_scale = d3.scaleQuantize().domain([0, 50]).range(['white','blue']);
        var k, i;
        for(k = 0; k < numParticipants; k++){
            participantSpeak[k] = 0;
        }
        // array of circles
        var circleData = [];

        var tooltip = d3.select("body")
                        .append("div")
                        .style("position", "absolute")
                        .style("z-index", "10")
                        .style("visibility", "hidden")
                        .style("color", "white")
                        .style("padding", "8px")
                        .style("background-color", "rgba(0, 0, 0, 0.50)")
                        .style("border-radius", "6px")
                        .style("font", "12px sans-serif")
                        .text("tooltip");

        var itr = 0;
        var alpha = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
        //http://bl.ocks.org/jfreyre/b1882159636cc9e1283a
        var colors = d3.scaleLinear().domain([1,50])
                            .interpolate(d3.interpolateHcl)
                            .range([d3.rgb("#FFFFFF"), d3.rgb('#191970')]);
        // controls radius of circle the nodes are around
        var radius = 25;
        var radius2 = 150;
        // creates container that the nodes are in with specific attributes
        var svgContainer = d3.select("body")
                            .append("svg")
                            .attr("width", 750)
                            .attr("height", 750)
                            .style("border", "1px solid black");
        get_curr_speaking();
        initial_draw(svgContainer,numParticipants,circleData);
        
        var userID_vals = [];
        var ui = 0;
        var step_value = 1;
        var total_time_num = parseInt(timeSpoken.reduce(reduction));
        var time_values = [],ui, time_acc = [],labels = [];
        for(ui = 0; ui <= total_time_num; ui++) {time_values[ui] = ui}; 
        time_acc = timeSpoken.slice();    // time scale
        for(ui = 1; ui < timeSpoken.length; ui++) {time_acc[ui] = time_acc[ui-1] + time_acc[ui]};      //
        for(ui = 0; ui < total_time_num; ui++) {labels[ui] = search_list(time_acc,ui);}; 
        for(ui = 0; ui < total_time_num; ui++){userID_vals[ui] = userID_test[labels[ui]];}
          
        //for(ui = 0; ui < total_time_num; ui++ ) {uid_labels[ui] = }
      
        var rad_mat = math.zeros(numParticipants,time_values.length),color_mat = math.zeros(numParticipants,time_values.length), curr_mat = math.zeros(numParticipants,time_values.length),prev_mat = math.zeros(numParticipants,time_values.length);

      
        generate_data(100);
      
        var timeline = d3.sliderHorizontal()
          .min(0)
          .max(total_time_num)
          .step(1)
          .width(1100)
          .on('onchange', slider_value => {
            print_all_figures(slider_value);
          });

        var g = d3.select("div#time_line").append("svg")
          .attr("width", 1200)
          .attr("height", 100)
          .append("g")
          .attr("transform", "translate(50,50)");

        g.call(timeline);
//        print_all_figures(100);
      
        //currently(0,timeSpoken[0],100,parseInt(circleData[0].attr("r")));
        // currently(i,timesec,ret,rad); 
        // start infinite loop here to update display over and over again
    
      function generate_data(ret)    // generate data
      {
      
        var k,t,ity;
        
      for(t = 0; t < total_time_num; t++)  
      {
        
            if(t > timeSpoken[0]-1)
            {
              var curr_sec = search_list(time_acc,t);
              while((userID_test[curr_sec])==(userID_test[curr_sec - 1])){ 
                if(curr_sec == 0){break;} curr_sec--;
                 }
              
              if(curr_sec == 0)
              {
               prev_mat.subset(math.index(userID_test[0],t),1);  // previous speaker for that instant
              }
              else
              {
               prev_mat.subset(math.index(userID_test[curr_sec - 1],t),1);  // previous speaker for that instant}
              }
            // prev_mat.subset(math.index(userID_test[search_list(time_acc,t) - 1],t),1);  // previous speaker for that instant
            //  prev_mat[test_data[labels[t]].userID][t] = 1;
            }
            // A[1][2]=0
           curr_mat.subset(math.index(userID_test[labels[t]],t),1);
           // curr_mat[test_data[labels[t]].userID][t] = 1;
        
        for(k = 0; k < numParticipants; k++)
            {
             
             rad_mat.subset(math.index(k,t),(radius + 1*(ret*(get_t_upto_curr_time(t,k)/60))));
          //rad_mat.subset(math.index(userID_test[labels[t]],t),(radius + 1*(ret*(get_sp_upto_curr_time(t,userID_test[labels[t]])/60))));
            // rad_mat[test_data[labels[t]].userID][t] = radius + 1*(ret*(t/60));
             color_mat.subset(math.index(k,t),colors(get_sp_upto_curr_time(t,k)));
          // color_mat.subset(math.index(userID_test[labels[t]],t),colors(search_for_instances(time_acc,t,userID_test[labels[t]]))); 
          // color_mat[test_data[labels[t]].userID][t] = color(search_for_instances(time_acc,t,test_data[labels[t]].userID));     
        }
      } 
       
        if(activate_overlap_detection)
           {
        
        for(t = 0; t < total_time_num; t++)
          {
        for(var i = 0; i < numParticipants; i++)
          {
            for(var j = 0; j < numParticipants; j++)
            {
              if(i == j)
              {continue;}
              
             if( (rad_mat.subset(math.index(i,t)) + rad_mat.subset(math.index(j,t))) > dist_calc(i,j) ) // overlap!
             {
             update_scale(t);
             }
            }      
          }
        }
      }
      }

      function print_all_figures(t)
      {
          if(t == total_time_num || t == 0)
          {
          previously_remove();
          }
        var h;
        
        for(h = 0; h < numParticipants; h++)
        {
          
          if(curr_mat.subset(math.index(h,t)) == 1)
          {
          currently(h);
          update_color_radius(color_mat.subset(math.index(h,t)),rad_mat.subset(math.index(h,t)),h);
          }
          else if(prev_mat.subset(math.index(h,t)) == 1)
          {
          previously(h);        
          }
          else
          {
          not_currently_previous(h);
          }
          
        }
      
      }
      
      function initial_draw(svgContainer,numParticipants,circleData)
        {
        
                // loops through for each participant and creates a node
        // and evenly spaces the nodes around the circle
        // in the future will use location data from Json to place people (Will need to generate relative coordinates in 2D unless the visualization is done in 3D)
        // also need to attach ID to each node
        for(i = 0; i < numParticipants; i++) 
        {
            // formula from here http://bl.ocks.org/bycoffe/3404776
            var angle = 0;
            var x = 0;
            var x_1 = [];
            var y = 0;
            var y_1 = [];
            angle = (i / (numParticipants/2)) * Math.PI;
            x = (radius2 * Math.cos(angle)) + (width/2);
            y = (radius2 * Math.sin(angle)) + (width/2);
			      x_1.push( ((radius2+8) * Math.cos(angle)) + (width/2) );
            y_1.push( ((radius2+8) * Math.sin(angle)) + (width/2) );
            var circle = svgContainer.append("circle")
                                .attr("cx", x)
                                .attr("cy", y)
                                .attr("r", 25)
                                .attr("id", i)
                                .style("stroke", "black")
                                .style("fill",colors(0))
                                .style("padding", 2)
                                .on("mouseover", function(d, id) {
                                    return tooltip.text("Times Spoken: " + parseInt(participantSpeak[id]) + " Total Time: "  + parseInt(participantTime[i]))
                                                .style("visibility", "visible");
                                })
                                .on("mousemove", function() {
                                    return tooltip.style("top", (d3.event.pageY-10)+"px")
                                                .style("left",(d3.event.pageX+10)+"px");
                                })
                                .on("mouseout", function() {
                                    return tooltip.style("visibility", "hidden");
                                })
            
            circleData.push(circle);

            var id = parseInt(circleData[i].attr("id"));

            var text = svgContainer.append("text")
                                .attr("x", x)
                                .attr("y", y + 6)
                                .text(alpha[id])
                                .attr("font-family", "san-serif")
                                .attr("font-size", "20px")
                                .attr("fill", "black")
                                .attr("text-anchor", "middle")
                                .on("mouseover", function(d, id) {
                                    return tooltip.text("Times Spoken: " + parseInt(participantSpeak[id]) + " Total Time: " + parseInt(participantTime[i]))
                                                .style("visibility", "visible");
                                })
                                .on("mousemove", function() {
                                    return tooltip.style("top", (d3.event.pageY-10)+"px")
                                                .style("left",(d3.event.pageX+10)+"px");
                                })
                                .on("mouseout", function() {
                                    return tooltip.style("visibility", "hidden");
                                })
               
            
        }

        }
                            
        // function will be passed the id of the person currently speaking
        // and highlight them
        
      function search_list(lis,ele)        // searches for which sector the time instant belongs to (the sectors are divided by the conversation snippets)
      {
        var i;
        
        if(ele < lis[0])
        {
        return 0;
        }
        
        for(i = 1; i < lis.length; i++)
        {
        
          if(lis[i-1] <= ele && lis[i] > ele )
          {
          return i;
          }
          
        }
         
        if(ele >= lis[lis.length - 1])
        {
        return lis.length - 1;
        }
      }
      
      function search_for_instances(lis,tim,userID)                // how many instances of userID before time tim?
      {
      var i; 
      var cnt = 0; 
        if(tim < test_data[0].time && userID == userID_test[0] )
        {
        cnt++; 
        }
      
        for(i = 0; i < lis.length; i++ )
         {
          if(lis[i] <= tim)
          {
            if(userID_test[i] == userID)
            {
            cnt++;
            }
          }
           else if(lis[lis.length-1]== tim)
           {
           break;
           }
           else
           {
           break;
           }
        }
        
        
        return cnt;
      }
      
      function get_curr_speaking()
      {
      var i,p;
        
        for (i = 0; i < numParticipants; i++)
        {
          for(p = 0; p < test_data.length; p++)
              {
                
              if(userID_test[p] == i) 
              {
                 participantSpeak[i]++;
              }
                
              }
        }
        
      }
      
      function get_sp_upto_curr_time(t,UID)                        // Get instances of when a person speaks
      {                                                            // by looking at the data
      var i,p;
        var tot_count = 0;
        
          for(p = 0; time_acc[p] <= t ; p++)
              {
                
              if(userID_test[p] == UID) 
              {
                tot_count++;                                        // The total count here is of the test_data points and not the sampled time points
              }
                
              }
        return tot_count;
      }
      
      function get_t_upto_curr_time(t,UID)                        // Get instances of when a person speaks
      {                                                            // by looking at the data
      var i,p;
        var tot_count = 0;
        
        if(t == total_time_num)
        {
        t--;
        }
        
          for(p = 0; p <= t ; p++)
              {
                
              if(userID_vals[p] == UID) 
              {
                tot_count++;                                        // The total count here is of the test_data points and not the sampled time points
              }
                
              }
        return tot_count;
      }
      
        function currently(i) 
      {
            
            //participantSpeak[i]++;
            //participantTime[i]+= timesec;
          
            circleData[i].style("stroke","red")
            .style("stroke-width", "5px");
         
            // increase one unit of radius every minute
            // every second then increases 1/60th of a unit, slow progression
            // assuming all individual conversation snippets do not exceed 15-20 seconds      
            // display previously spoken text here?

        }
        
      function not_currently_previous(i)
      {
      circleData[i]
        .style("stroke","black")
        .style("stroke-width","1px");
      }
      
      
      function update_color_radius(colo,newrad,i)
      {
           circleData[i]
            .style("fill",colo)
            .attr("r",newrad); 
      }
      
        // function will be passed the id of the person who
        // just spoke and highlight them
        // will also darken the color of the circle by 1 shade
        
        // Anyone who may have spoken previously will have their transcript 
        // displayed next to them in a text box
        
        function previously(i) // ,sti) 
        {

          previously_remove();
          
          circleData[i].style("stroke", "lightpink")
                        .style("stroke-width", "5px");
                // data[i].style("fill", colors[5]);
               
       //        var ls = sti.length;
       // TODO: After succesfully obtaining transcript data, get character count
       // and determine width of the rectangle on basis of that
       // Center text on rectangle
          
          var x_r = parseInt(circleData[i].attr("cx"));
          var y_r = parseInt(circleData[i].attr("cy"));
               
                 svgContainer.append("rect")
                .attr("x", parseInt(x_r) + 30)
                .attr("y", parseInt(y_r) + 30)
                .attr("rx",10)
                .attr("ry",10)
                .attr("id","rect_box")
                .attr("width", 100)
                .attr("height", 30)
                .attr("stroke","black")
                .attr("fill","none")
                .attr("id","rect_box")
                .attr("border", "1px solid black");
                
                
                svgContainer.append("text")
                .attr("x",parseInt(x_r) + 35)
                .attr("y",parseInt(y_r) + 50)
                .attr("id","text_box")
                .text(test_data[i].speech);
                
               
        
        }
      
		// Remove the text box for use with other transcript elements 
       function previously_remove()
       {
            svgContainer.select("#rect_box").remove();
            svgContainer.select("#text_box").remove();    
       }
        // function will be passed the amount of time someone spoke in seconds
        // and change the size of the node proportionally to the amount
        // of time
        // function will also be passed id of person who spoke
      
      
      
      function update_scale(scale_pos)
      {
      
        for(var k = scale_pos; k < total_time_num; k++ )
        {
          for(var p = 0; p < numParticipants; p++)
              {
              rad_mat.subset(math.index(p,k),parseInt(rad_mat.subset(math.index(p,k)))*scale_factor);
              }
        }
        
      }
      
      function dist_calc(I,J)
      {
      return Math.sqrt( Math.pow(parseFloat(circleData[I].attr("cx")) - parseFloat(circleData[J].attr("cx")) ,2) + Math.pow( parseFloat(circleData[I].attr("cy")) - parseFloat(circleData[J].attr("cy")) ,2) );      
      }
      
      function reduction(val,ele)
      {return val+ele;}
      
        // ourRequest.send();
    </script>
    
</body>
</html>
