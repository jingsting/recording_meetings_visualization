<!DOCTYPE html>
<head>
    <meta charset = "utf-8">
    <style>
        /* sets the style of the title Meeting Analysis */
        h1 {
            font-size: 50px;
            color: navy;
            font-family: HelvNeueLightForIBM, Helvetica Neue, Arial, Helvetica, sans-serif;
            text-align: left;
        }
        body {
            background-color: white;
        }
    </style>
    <title>Visualization</title>
</head>
<body>
    <h1>Meeting Analysis</h1>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
        // var ourRequest = new XMLHttpRequest();
        // ourRequest.open('GET', *********FILE_LOCATION***************)
        // ourRequest.onload = function(){
        //     var RAWJSON_INFO=JSON.parse(ourRequest.responseText);
        // arbitrarily sets width, height, and diameter
        var width = 750;
        var height = 750;
        // controls the number of nodes
        // will read from Json file
        var numParticipants = 6;
        var participantSpeak = [];
        var participantTimeOriginal = [];
        var participantTimeChanging = [];
        var k, i;
        for(k = 0; k < numParticipants; k++){
            participantSpeak[k] = 0;
            participantTimeOriginal[k] = 0;
            participantTimeChanging[k] = 0;
        }
        // array of circles
        var circleData = [];
        var mouseoverData = [];
        var angle = 0;
        var x = 0;
        var x_1 = [];
        var y = 0;
        var y_1 = [];

        var tooltip = d3.select("body")
                        .append("div")
                        .style("position", "absolute")
                        .style("z-index", "10")
                        .style("visibility", "hidden")
                        .style("color", "white")
                        .style("padding", "8px")
                        .style("background-color", "rgba(0, 0, 0, 0.50)")
                        .style("border-radius", "6px")
                        .style("font", "12px sans-serif")
                        .text("tooltip");

        
        var alpha = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
        //http://bl.ocks.org/jfreyre/b1882159636cc9e1283a
        var colors = d3.scaleLinear().domain([1,50])
                            .interpolate(d3.interpolateHcl)
                            .range([d3.rgb("#FFFFFF"), d3.rgb('#191970')])
        // controls radius of circle the nodes are around
        var radius = 200;
        // creates container that the nodes are in with specific attributes
        var svgContainer = d3.select("body")
                            .append("svg")
                            .attr("width", width)
                            .attr("height", height)
                            .style("border", "1px solid black");


        // for(var i = 0; i < numParticipants; i++) {
        //     var obj = {
        //         "id": i.toString(),
        //         "label": alpha[i],
        //         "participantSpeak": 0,
        //         "participantTimeTotal": 0,
        //         "participantTimeTemp": 0
        //     };

        //     mouseoverData.push(obj);
        // }
        
        // loops through for each participant and creates a node
        // and evenly spaces the nodes around the circle
        // in the future will use location data from Json to place people (Will need to generate relative coordinates in 2D unless the visualization is done in 3D)
        // also need to attach ID to each node
        for(i = 0; i < numParticipants; i++) 
        {
            // formula from here http://bl.ocks.org/bycoffe/3404776
            angle = (i / (numParticipants/2)) * Math.PI;
            x = (radius * Math.cos(angle)) + (width/2);
            y = (radius * Math.sin(angle)) + (width/2);
			x_1.push( ((radius+8) * Math.cos(angle)) + (width/2) );
            y_1.push( ((radius+8) * Math.sin(angle)) + (width/2) );
            var circle = svgContainer.append("circle")
                                .attr("cx", x)
                                .attr("cy", y)
                                .attr("r", 25)
                                .attr("id", i)
                                .style("stroke", "black")
                                .style("fill",colors(0))
                                .style("outline", "black")
                                .on("mouseover", function(d) {
                                    return tooltip.text("Times Spoken: " + " Total Time: "  + " seconds")
                                                .style("visibility", "visible");
                                })
                                .on("mousemove", function() {
                                    return tooltip.style("top", (d3.event.pageY-10)+"px")
                                                .style("left",(d3.event.pageX+10)+"px");
                                })
                                .on("mouseout", function() {
                                    return tooltip.style("visibility", "hidden");
                                })
            
            circleData.push(circle);
            var id = parseInt(circleData[i].attr("id"));

            var text = svgContainer.append("text")
                                .attr("x", x)
                                .attr("y", y + 6)
                                .text(alpha[id])
                                .attr("id", "label")
                                .attr("font-family", "san-serif")
                                .attr("font-size", "20px")
                                .attr("fill", "black")
                                .attr("text-anchor", "middle")
                                .on("mouseover", function(d) {
                                    return tooltip.text("Times Spoken: "  + " Total Time: " + " seconds")
                                                .style("visibility", "visible");
                                })
                                .on("mousemove", function() {
                                    return tooltip.style("top", (d3.event.pageY-10)+"px")
                                                .style("left",(d3.event.pageX+10)+"px");
                                })
                                .on("mouseout", function() {
                                    return tooltip.style("visibility", "hidden");
                                })
               
            
        }
        
        var trans = "Hello, my name is Zhao";
        var newTrans = wrapText(trans, 10);

        function currently(i, timsec) {
            participantSpeak[i]++;
            participantTimeOriginal[i]+= timsec;
          
            circleData[i].style("stroke","red")
                        .style("stroke-width", "5px");            
        }

        // function  highlights circle, expands the radius,
        // changes the color, and shows the transcript
        // make sure to check for collisions
        // could check before expanding and scale down if needed
        // or increase size then check then scale down
        // args: svg container, x val if circle, y val of circle, id,
        // time spoke in seconds, and scaling factor
        // scaling factor currently arbitrarily 10
        function previously(svgC, x_r, y_r, i, timsec, factor) {
            // increases the number of times the person spoke
            participantSpeak[i]++;
            // changes the shade of the fill by 1 on the color scale
            circleData[i].style("fill", colors(participantSpeak[i]));
            // highlights circle with light pink ring to
            // incidate that the person had just spoken
            circleData[i].style("stroke", "lightpink")
                        .style("stroke-width", "5px");

            // creates the rectangle that the text is shown in
            // TODO: make the size of the textbox dynamic and
            // make sure the text does not go outside of the svgContainer
            svgC.append("rect")
                .attr("x", parseInt(x_r[i]) + 30 + (1*(factor*timsec/60)))
                .attr("y", parseInt(y_r[i]) + 30 + (1*(factor*timsec/60)))
                .attr("rx",10)
                .attr("ry",10)
                .attr("id","rect_box")
                .attr("width", 100)
                .attr("height", 30)
                .attr("stroke","black")
                .attr("fill","none")
                .attr("id","rect_box")
                .attr("border", "1px solid black");

            participantTimeOriginal[i] += timsec;
            var rad = parseInt(circleData[i].attr("r"));
            // increases on eunit of radius every minute
            // every second then increases 1/60th of a unit
            circleData[i].attr("r", (rad + 1*(factor*timsec/60)));


            // adds the text "in" the textbox
            svgC.append("text")
                .attr("x",parseInt(x_r[i]) + 35 + (1*(factor*timsec/60)))
                .attr("y",parseInt(y_r[i]) + 50 + (1*(factor*timsec/60)))
                .attr("id","text_box")
                .text(newTrans);

            // check for intersection and if two circles are intersecting
            // will resize so there is no intersection
            if(checkIntersecting()) {
                scaleDown(participantTimeOriginal, circleData, factor);
                if(checkIntersecting()) {
                    var newRad = 1.1 * radius;
                    radius = newRad;
                    svgContainer.selectAll("#label").remove();
                    for(var i = 0; i < numParticipants; i++) {
                        angle = (i / (numParticipants/2)) * Math.PI;
                        x = (radius * Math.cos(angle)) + (width/2);
                        y = (radius * Math.sin(angle)) + (width/2);
                        x_1.push( ((radius+8) * Math.cos(angle)) + (width/2) );
                        y_1.push( ((radius+8) * Math.sin(angle)) + (width/2) );
                        circleData[i].attr("cx", x)
                                    .attr("cy", y);
                        
                        var text = svgContainer.append("text")
                            .attr("x", x)
                            .attr("y", y + 6)
                            .text(alpha[i])
                            .attr("id", "label")
                            .attr("font-family", "san-serif")
                            .attr("font-size", "20px")
                            .attr("fill", "black")
                            .attr("text-anchor", "middle")
                            .on("mouseover", function(d) {
                                return tooltip.text("Times Spoken: "  + " Total Time: " + " seconds")
                                            .style("visibility", "visible");
                            })
                            .on("mousemove", function() {
                                return tooltip.style("top", (d3.event.pageY-10)+"px")
                                            .style("left",(d3.event.pageX+10)+"px");
                            })
                            .on("mouseout", function() {
                                return tooltip.style("visibility", "hidden");
                            })
                        }
                }
            }
        }

        // function removes the textbox and transcript
        // as well as the highlighted ring
        function removePrev(svgC, i) {
            svgC.select("#rect_box").remove();
            svgC.select("#text_box").remove();

            circleData[i].style("stroke", "black");
            circleData[i].style("stroke-width", "1px");
        }

        function scaleDown(originalData,circles, fac) {
            var newData = [];
            var minData = d3.min(originalData);
            var maxData = d3.max(originalData);

            for(var i = 0; i < originalData.length; i++) {
                newData[i] = originalData[i] * .25;
                console.log(newData[i]);
                circles[i].attr("r", (25 + 1*(fac*newData[i]/60)));
            }
            participantTimeChanging = newData;
        }

        // http://www.inkfood.com/collision-detection-with-svg/
        // https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
        function checkIntersecting() {
            for(var i = 0; i < numParticipants; i++) {
                for(var j = 0; j < numParticipants; j++) {
                    if(i == j) { continue; }
                    var distX = Math.abs(circleData[i].attr("cx") - circleData[j].attr("cx")) - 5;
                    var distY = Math.abs(circleData[i].attr("cy") - circleData[j].attr("cy")) - 5;
                    var distance = Math.abs(Math.sqrt((distX * distX) + (distY * distY)));
                    var sum = parseInt(circleData[i].attr("r")) + parseInt(circleData[j].attr("r"));
                    if(distance < sum) {
                        return true;
                    }
                }
            } 
            return false;
        }

        function wrapText(transcript, width) {
            var stringArray = transcript.split(" ");
            var newString = "";
            console.log(stringArray);
            var currentLine = 0;
            var numLines = 1;
            for(var i = 0; i < stringArray.length; i++) {
                console.log(stringArray[i].length);

                if((stringArray[i].length + currentLine + 1) < width) {
                    currentLine += stringArray[i].length;
                    newString += (stringArray[i] + " ");
                }
                else if((stringArray[i].length + currentLine + 1) > width) {
                    newString += ("\n");
                    numLines++;
                    currentLine = 0;
                    newString+= (stringArray[i] + " ");
                    currentLine += stringArray[i].length;
                }
            }
            console.log(newString);
            return newString;
        }

        // ourRequest.send();
    </script>
    
</body>

